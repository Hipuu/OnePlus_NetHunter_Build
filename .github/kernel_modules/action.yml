name: Build OnePlus kernel modules

permissions:
  contents: write
  actions: write

inputs:
  op_config_json:
    description: 'JSON string containing full device config'
    required: true
    type: string
  optimize_level:
    required: false
    type: string
    default: O2  # Choices: O2 or O3
  manifest:
    required: true
    type: string
    default: OOS15

runs:
  using: composite
  steps:
    - name: Parse op_config_json
      shell: bash
      run: |
        set -euo pipefail
        echo '${{ inputs.op_config_json }}' > /tmp/config.json
        jq -r 'to_entries[] | "OP_\(.key | ascii_upcase)=\(.value)"' /tmp/config.json >> "$GITHUB_ENV"
        echo "Parsed config:"
        jq '.' /tmp/config.json
    
    - name: Set Manifest
      shell: bash
      run: |
        set -euo pipefail
        echo "Using manifest from config: $OP_MANIFEST"
    
    - name: Validate Inputs
      shell: bash
      run: |
        set -euo pipefail
        echo "::group::Validate inputs"
        model="$OP_MODEL"
        soc="$OP_SOC"
        branch="$OP_BRANCH"
        manifest="$OP_MANIFEST"
        optimize='${{ inputs.optimize_level }}'
        rust_build="$OP_RUST_BUILD"
    
        [[ -n "$model" ]] || { echo "Input 'model' cannot be empty"; exit 1; }
        [[ -n "$soc" ]] || { echo "Input 'soc' cannot be empty"; exit 1; }
        [[ -n "$branch" ]] || { echo "Input 'branch' cannot be empty"; exit 1; }
        [[ -n "$manifest" ]] || { echo "Input 'manifest' cannot be empty"; exit 1; }
        [[ -n "$rust_build" ]] || { echo "Input 'rust_build' cannot be empty"; exit 1; }
    
        case "$optimize" in
          O2|O3) ;; 
          *) echo "optimize_level must be O2 or O3; got '$optimize'"; exit 1 ;; 
        esac
        echo "Input validation OK."
        echo "::endgroup::"

    - name: Install Minimal Dependencies
      shell: bash
      run: |
        set -euo pipefail
        echo "::group::Install deps"
        sudo apt-get -o Acquire::Retries=3 update -qq
        sudo DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
          git curl ca-certificates build-essential clang lld flex bison \
          libelf-dev libssl-dev libncurses-dev zlib1g-dev liblz4-tool \
          libxml2-utils rsync unzip dwarves file python3 ccache
        sudo apt-get clean
        echo "::endgroup::"

    - name: Install bindgen only (no rustc)
      shell: bash
      if: ${{ env.OP_RUST_BUILD == 'true' }}
      run: |
        # Install bindgen via cargo (no full rustc needed)
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain none
        source $HOME/.cargo/env
        
        # Install bindgen CLI only (~50-100MB total)
        cargo install bindgen-cli --version 0.69.5
        
        # Verify
        bindgen --version
        which bindgen

    - name: Setup Base Environment
      shell: bash
      run: |
        set -euo pipefail
        CONFIG="$OP_MODEL"
        echo "CONFIG=$CONFIG" >> "$GITHUB_ENV"
        REPO="/usr/local/bin/repo"
        if [ ! -x "$REPO" ]; then
          curl -s https://storage.googleapis.com/git-repo-downloads/repo -o "$REPO"
          chmod +x "$REPO"
        fi
        echo "REPO=$REPO" >> "$GITHUB_ENV"

    - name: Initialize and Sync Kernel Source
      shell: bash
      run: |
        set -euo pipefail
        echo "Creating folder for configuration: $CONFIG"
        mkdir -p "$CONFIG"
        cd "$CONFIG"
        echo "Initializing and syncing kernel source..."
        
        if [[ "$OP_MANIFEST" == https://* ]]; then
          mkdir -p .repo/manifests
          curl --fail --show-error --location --proto '=https' "$OP_MANIFEST" -o .repo/manifests/temp_manifest.xml
          "$REPO" init -u https://github.com/OnePlusOSS/kernel_manifest.git -b oneplus/sm8650 -m temp_manifest.xml --repo-rev=v2.16 --depth=1 --no-clone-bundle --no-tags
        elif [[ "$OP_BRANCH" == wild/* ]]; then
           OS_LOWER=$(echo "$OP_OS_VERSION" | tr '[:upper:]' '[:lower:]')
           if [ -f "../manifests/$OS_LOWER/$OP_MANIFEST" ]; then
             mkdir -p .repo/manifests
             cp "../manifests/$OS_LOWER/$OP_MANIFEST" .repo/manifests/temp_manifest.xml
             "$REPO" init -u https://github.com/OnePlusOSS/kernel_manifest.git -b "oneplus/sm8650" -m temp_manifest.xml --repo-rev=v2.16 --depth=1 --no-clone-bundle --no-tags
           else
             "$REPO" init -u https://github.com/OnePlusOSS/kernel_manifest.git -b "$OP_BRANCH" -m "$OP_MANIFEST" --repo-rev=v2.16 --depth=1 --no-clone-bundle --no-tags
           fi
        else
          "$REPO" init -u https://github.com/OnePlusOSS/kernel_manifest.git -b "$OP_BRANCH" -m "$OP_MANIFEST" --repo-rev=v2.16 --depth=1 --no-clone-bundle --no-tags
        fi
        
        "$REPO" --version
        success=false
        for i in 1 2 3; do
          if "$REPO" sync -c --no-clone-bundle --no-tags --optimized-fetch \
             -j"$(nproc --all)" --fail-fast; then
            success=true
            break
          fi
          echo "repo sync attempt $i failed; retrying..."
          sleep 30
        done
        $success || { echo "repo sync failed after 3 attempts"; exit 1; }
        
    - name: Set Directories
      shell: bash
      run: |
        set -euo pipefail
        CONFIG_DIR="$GITHUB_WORKSPACE/$CONFIG"
        
        COMMON_DIR="$CONFIG_DIR/kernel_platform/common"
        if [ ! -d "$COMMON_DIR" ]; then
            echo "Error: Common kernel directory not found at $COMMON_DIR"
            exit 1
        fi
        echo "COMMON_KERNEL_DIR=$COMMON_DIR" >> "$GITHUB_ENV"
        
        if [ -d "$CONFIG_DIR/kernel_platform/msm-kernel" ]; then
             VENDOR_DIR="$CONFIG_DIR/kernel_platform/msm-kernel"
        else
             VENDOR_DIR="$CONFIG_DIR"
        fi
        echo "VENDOR_KERNEL_DIR=$VENDOR_DIR" >> "$GITHUB_ENV"
        
        ARTIFACTS_DIR="$CONFIG_DIR/artifacts"
        mkdir -p "$ARTIFACTS_DIR"
        
    - name: Get Kernel Version Info
      shell: bash
      run: |
        set -euo pipefail
        cd "$COMMON_KERNEL_DIR"

        CONFIG_FILES=("build.config.common" "build.config.constants")
        BRANCH_LINE=""
        for f in "${CONFIG_FILES[@]}"; do
          if [ -f "$f" ]; then
            l=$(grep '^[[:space:]]*BRANCH=' "$f" || true)
            if [ -n "$l" ]; then BRANCH_LINE="$l"; break; fi
          fi
        done
        if [ -z "$BRANCH_LINE" ]; then
          echo "Error: No BRANCH= found"; exit 1
        fi
        BRANCH_VALUE="${BRANCH_LINE#*=}"
        ANDROID_VERSION="${BRANCH_VALUE%-*}"
        if [ -z "$ANDROID_VERSION" ]; then
          echo "Could not parse android version from BRANCH=$BRANCH_VALUE"
          exit 1
        fi
        VERSION=$(grep '^VERSION *=' Makefile | awk '{print $3}')
        PATCHLEVEL=$(grep '^PATCHLEVEL *=' Makefile | awk '{print $3}')
        SUBLEVEL=$(grep '^SUBLEVEL *=' Makefile | awk '{print $3}')
        FULL_VERSION="$VERSION.$PATCHLEVEL.$SUBLEVEL"
        
        ARTIFACTS_DIR="$GITHUB_WORKSPACE/$CONFIG/artifacts"
        cd "$ARTIFACTS_DIR"
        echo "ANDROID_VER=$ANDROID_VERSION" >> "$GITHUB_ENV"
        echo "KERNEL_VER=$VERSION.$PATCHLEVEL" >> "$GITHUB_ENV"
        echo "KERNEL_FULL_VER=$ANDROID_VERSION-$FULL_VERSION" >> "$GITHUB_ENV"
        echo "SUSFS_KERNEL_BRANCH=gki-$ANDROID_VERSION-$VERSION.$PATCHLEVEL" >> "$GITHUB_ENV"

    - name: Setup ccache
      uses: hendrikmuhs/ccache-action@v1.2.19
      with:
        key: ${{ env.CONFIG }}-modules-${{ env.KERNEL_FULL_VER }}
        max-size: 5G
        append-timestamp: false
        create-symlink: true
        job-summary: 'CCache stats'
        evict-old-files: 'job'

    - name: Clean Up ABI Protected Exports
      shell: bash
      run: |
        set -euo pipefail
        cd "$CONFIG/kernel_platform"
        rm -f common/android/abi_gki_protected_exports_* || true
        if [ -d "msm-kernel" ]; then
            rm -f msm-kernel/android/abi_gki_protected_exports_* || true
        fi
        df -h

    - name: Add nethunter specfic drivers already present in kernel to be built as modules
      shell: bash
      run: |
        set -euo pipefail
        cd "$COMMON_KERNEL_DIR"
        
        cat >> arch/arm64/configs/gki_defconfig <<EOF

        CONFIG_RFKILL=m
        CONFIG_CFG80211=m
        CONFIG_MAC80211=m

        CONFIG_ATH10K=m
        CONFIG_ATH10K_USB=m

        CONFIG_ATH11K=m

        CONFIG_MT7601U=m
        CONFIG_MT76_CORE=m

        CONFIG_MT76_CORE=m
        CONFIG_MT76_USB=m
        CONFIG_MT76x02_LIB=m
        CONFIG_MT76x02_USB=m
        CONFIG_MT76_CONNAC_LIB=m

        CONFIG_MT7603E=m
        CONFIG_MT76x2_COMMON=m
        CONFIG_MT76x0_COMMON=m
        CONFIG_MT7615_COMMON=m
        CONFIG_MT7915E=m
        CONFIG_MT7921E=m
        
        CONFIG_MAC80211_LEDS=m

        CONFIG_CAN_SLCAN=m
        EOF

    - name: Add memkernel module
      shell: bash
      run: |
        set -euo pipefail
        cd "$COMMON_KERNEL_DIR"
        curl -LSs "https://raw.githubusercontent.com/Poko-Apps/MemKernel/main/kernel/setup.sh" | bash -s M br0k3n

    - name: Add rtw88 modules
      shell: bash
      run: |
        set -euo pipefail
        cd "$COMMON_KERNEL_DIR/drivers/net/wireless/realtek/"
        rm -rf rtw88
        git clone https://github.com/lwfinger/rtw88.git
        sed -i 's/$(CONFIG_RTW88)/m/g' Makefile
        sed -i '/^source "drivers\/net\/wireless\/realtek\/rtw88\/Kconfig"$/s/.*/ /' Kconfig

    - name: Detect Clang and Rust (toolchain for build)
      shell: bash
      run: |
        set -euo pipefail
        KP="$GITHUB_WORKSPACE/$CONFIG/kernel_platform"
        CLANG_FOUND=false
        RUSTC_FOUND=false
        
        for base in "$KP/prebuilts" "$KP/prebuilts-master"; do
          [ -d "$base/clang/host/linux-x86" ] || continue
          latest=$(ls -d "$base"/clang/host/linux-x86/clang-r*/ 2>/dev/null | sort -V | tail -n1 || true)
          if [ -n "$latest" ] && [ -x "$latest/bin/clang" ]; then
            CLANG_BIN="$latest/bin"
            CLANG_FOUND=true
            break
          fi
        done
        
        for base in "$KP/prebuilts" "$KP/prebuilts-master"; do
          [ -d "$base/rust/linux-x86/" ] || continue
          ls -la "$base/rust/linux-x86/"
          latest=$(ls -d "$base/rust/linux-x86/1."* 2>/dev/null | sort -V | head -n1 || true)
          if [ -n "$latest" ] && [ -x "$latest/bin/rustc" ]; then
            RUSTC_BIN="$latest/bin"
            RUSTC_FOUND=true
            break
          fi
        done
        
        # Fallback: Download AOSP Clang if not found
        if ! $CLANG_FOUND; then
           echo "⬇️ Prebuilt Clang not found. Downloading AOSP Clang r487747c..."
           mkdir -p "$KP/prebuilts/clang/host/linux-x86/clang-r487747c"
           cd "$KP/prebuilts/clang/host/linux-x86/clang-r487747c"
           curl -L -k https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/heads/master/clang-r487747c.tar.gz -o clang.tar.gz
           tar -xzf clang.tar.gz
           rm clang.tar.gz
           CLANG_BIN="$PWD/bin"
           CLANG_FOUND=true
        fi
        
        if ! $CLANG_FOUND && command -v clang >/dev/null 2>&1; then
          CLANG_BIN="$(dirname "$(command -v clang)")"
          CLANG_FOUND=true
          echo "Using system clang."
        fi
        
        $CLANG_FOUND || { echo "No clang toolchain found"; exit 1; }
        echo "CLANG_BIN_PATH=$CLANG_BIN" >> "$GITHUB_ENV"
        CLANG_VERSION="$($CLANG_BIN/clang --version | head -n1)"
        echo "CLANG_VERSION=$CLANG_VERSION" >> "$GITHUB_ENV"
        echo "Detected Clang: $CLANG_VERSION"
        
        if [ "$RUSTC_FOUND" = true ]; then
          echo "RUSTC_BIN_PATH=$RUSTC_BIN" >> "$GITHUB_ENV"
          RUSTC_VERSION="$("$RUSTC_BIN/rustc" --version | head -n1)"
          echo "RUSTC_VERSION=$RUSTC_VERSION" >> "$GITHUB_ENV"
          echo "✅ Detected RUSTC: $RUSTC_VERSION"
        else
           echo "::warning::No RUST toolchain found! Ignoring"
        fi

    - name: Fix Clang 18+ Compatibility
      shell: bash
      run: |
        set -euo pipefail
        echo "::group::Fix Clang compatibility"
        cd "$COMMON_KERNEL_DIR"
        
        # Fix stack_pointer.h
        SP_H="arch/arm64/include/asm/stack_pointer.h"
        if [ -f "$SP_H" ]; then
            echo "--- Before Patching $SP_H ---"
            grep "current_stack_pointer" "$SP_H" || echo "Pattern not found"
            
            sed -i 's/register unsigned long current_stack_pointer asm ("sp");/#define current_stack_pointer ({ unsigned long sp; asm ("mov %0, sp" : "=r" (sp)); sp; })/' "$SP_H" || true
            
            echo "--- After Patching $SP_H ---"
            grep "current_stack_pointer" "$SP_H" || echo "Pattern not found"
        else
            echo "Warning: $SP_H not found"
        fi
        
        # Fix kgdb.h
        KGDB_H="arch/arm64/include/asm/kgdb.h"
        if [ -f "$KGDB_H" ]; then
            echo "--- Before Patching $KGDB_H ---"
            grep "asm.*brk" "$KGDB_H" || echo "Pattern not found"
            
            sed -i 's/asm ("brk %0" : : "I"/asm ("brk %0" : : "i"/' "$KGDB_H" || true
            
            echo "--- After Patching $KGDB_H ---"
            grep "asm.*brk" "$KGDB_H" || echo "Pattern not found"
        else
             echo "Warning: $KGDB_H not found"
        fi
        echo "::endgroup::"

    - name: Build Kernel Modules 
      shell: bash
      run: |
        set -euo pipefail
        
        cd "$COMMON_KERNEL_DIR"
        
        export PATH="${CLANG_BIN_PATH}:$PATH" 
        export PATH="/usr/lib/ccache:$PATH"
        
        echo "=== Compiler Version ==="
        clang --version
        echo "========================"
        set -euo pipefail
        
        cd "$COMMON_KERNEL_DIR"
        
        export PATH="${CLANG_BIN_PATH}:$PATH" 
        export PATH="/usr/lib/ccache:$PATH"
        
        if [ -n "${RUSTC_BIN_PATH:-}" ]; then
          export PATH="${RUSTC_BIN_PATH}:${PATH}"
          export RUSTC="$RUSTC_BIN_PATH/rustc"
          if [ "${{ env.OP_RUST_BUILD}}" = "true" ]; then
            export LIBCLANG_PATH="$CLANG_BIN_PATH/../lib"
            export BINDGEN="bindgen"
          fi
        fi

        VENDOR_CONFIG="$VENDOR_KERNEL_DIR/arch/arm64/configs/vendor/${OP_SOC}_GKI.config"
        FALLBACK_CONFIG="$VENDOR_KERNEL_DIR/arch/arm64/configs/vendor/pineapple_GKI.config"
        
        if [ -f "$VENDOR_CONFIG" ]; then
           echo "Merging vendor config: $VENDOR_CONFIG"
           cat "$VENDOR_CONFIG" >> ./arch/arm64/configs/gki_defconfig
        elif [ -f "$FALLBACK_CONFIG" ]; then
           echo "Merging fallback vendor config: $FALLBACK_CONFIG"
           cat "$FALLBACK_CONFIG" >> ./arch/arm64/configs/gki_defconfig
        else
           echo "Warning: No vendor GKI config found!"
        fi

        echo "CONFIG_LTO_CLANG_THIN=y" >> ./arch/arm64/configs/gki_defconfig                                                                            
        echo "CONFIG_LTO_CLANG=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y" >> "./arch/arm64/configs/gki_defconfig"
        echo "CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE_O3=n" >> "./arch/arm64/configs/gki_defconfig"
        
        if [ "${{ env.OP_RUST_BUILD}}" = "true" ]; then
           echo "CONFIG_ANDROID_BINDER_IPC_RUST=m" >> "./arch/arm64/configs/gki_defconfig"
           echo "CONFIG_RUST=y" >> "./arch/arm64/configs/gki_defconfig"
        fi

        INSTALL_MOD_PATH="$COMMON_KERNEL_DIR/out"
        
        echo "Building kernel modules..."
        echo "=== DEBUG: gki_defconfig content ==="
        cat arch/arm64/configs/gki_defconfig
        echo "===================================="
        
        make ARCH=arm64 LLVM=1 O=out gki_defconfig   
        make V=1 -j$(nproc --all) ARCH=arm64 LLVM=1 O=out CC="ccache clang" modules       
        make -j$(nproc --all) ARCH=arm64 LLVM=1 O=out INSTALL_MOD_PATH=$INSTALL_MOD_PATH modules_install
        
    - name: Filter modules
      shell: bash
      run: |
        set -euo pipefail
        OUT="$COMMON_KERNEL_DIR/out"
        
        if [ ! -d "$OUT/lib/modules" ]; then
            echo "Error: No modules found in $OUT/lib/modules"
            exit 1
        fi

        UNAME=$(ls "$OUT/lib/modules/")

        echo "Copying all modules to $OUT/modules"
        cd "$OUT"
        mkdir -p modules
        find lib/modules/"$UNAME" -type f -name '*.ko' -exec cp {} modules/ \;
        echo "Total modules copied: $(find modules -type f -name '*.ko' | wc -l)"

        echo "Removing unnecessary modules..."
        cd modules
        curl -L -o default_modules.txt https://raw.githubusercontent.com/nullptr-t-oss/kernel_patches/refs/heads/main/default_modules.txt
        
        while IFS= read -r module; do
          if [ -e "$module" ]; then
            rm -f "$module"
            echo "Removed module: $module"
          fi
        done < default_modules.txt
        cd ..
        echo "Modules remaining after filtering: $(find modules -type f -name '*.ko' | wc -l)"

    - name: Create Kernel Modules zip
      id: create_zip
      shell: bash
      run: |
        set -euo pipefail
        CONFIG_DIR="$GITHUB_WORKSPACE/$CONFIG"
        OUT="$COMMON_KERNEL_DIR/out"
        MODULES_SRC="$OUT/modules"
        MODULES_ZIP="$CONFIG_DIR/artifacts/kernel_modules_${{ env.OP_MODEL }}_${{ env.OP_OS_VERSION }}.zip"
        mkdir -p "$CONFIG_DIR/artifacts"
        find "$MODULES_SRC" -type f -name '*.ko' -print0 | xargs -0 zip -j "$MODULES_ZIP"
        echo "Packaged kernel modules to $MODULES_ZIP"
        
    - name: Final Build Summary
      shell: bash
      run: |
        set -euo pipefail
        {
          echo "CCache Statistics :"
          echo "$(/usr/bin/ccache -s)"
        } | tee summary.txt
        {
          echo "### Kernel Modules Build Summary"
          echo ""
          echo "CCache Statistics :"
          echo "$(ccache -s -v)"
        } >> "$GITHUB_STEP_SUMMARY"
        
    - name: Cleanup old ccache
      shell: bash
      run: |
        set -euo pipefail
        echo "Deleting old ccache..."
        gh cache delete ccache-${{ env.CONFIG }}-modules-${{ env.KERNEL_FULL_VER }}- || true

    - name: Upload Kernel Modules zip
      if: success() && steps.create_zip.conclusion == 'success'
      uses: actions/upload-artifact@v4
      with:
        name: kernel-modules-${{ env.CONFIG }}-${{ env.OP_OS_VERSION }}
        path: ${{ env.CONFIG }}/artifacts/